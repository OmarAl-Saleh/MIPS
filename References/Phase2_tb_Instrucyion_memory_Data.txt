
**********************************Evaluation Sheet B.1 and B.2  HEX Instructions
BENCHMARK1
8C010000
34020004
2003FFFE
8C040004
00212820
00223022
00643024
00223825
00232826
00223027
00823800
00222802
00212820
00A43022
00A63824
34A5000F
AC010000
AC040004
8C050000
8C060004
30C7000B
AC070008
8C0A0000
AC05000C
10210001
00422820
14010002
00423020
00843820
08000020
00422820
00843020
00000020
B4221820

******************************

BM2
0C000002
08000019
8C100000
20080000
20110013
19110012
20090000
02295022
192A000D
01205880
020B6020
8D8D0000
8D8E0004
19AE0001
08000014
01A07820
01C06820
01E07020
AD8D0000
AD8E0004
21290001
08000008
21080001
08000005
03E00008
00000020
B4221820





**********************************Evaluation Sheet B.1 and B.2  Binary Instructions 

Benchmark One 

								
								/*Address 0 */	inst_mem[0] =32'b10001100000000010000000000000000; //		Lw r1,0(R0)
								/*Address 4 */	inst_mem[1] =32'b00110100000000100000000000000100; //		ori r2 ,r0,4
								/*Address 8 */	inst_mem[2] =32'b00100000000000111111111111111110;   //		addi r3,r0,-2
								/*Address 12 */inst_mem[3] =32'b10001100000001000000000000000100; //		Lw r4,4(R0)
								
								/*Address 16 */	inst_mem[4] =32'b00000000001000010010100000100000; //		ADD R5,R1,R1
								/*Address 20 */	inst_mem[5] =32'b00000000001000100011000000100010; //		SUB R6,R1,R2
								/*Address 24 */	inst_mem[6] =32'b00000000011001000011000000100100;//		AND R6,R3,R4
								/*Address 28 */	inst_mem[7] =32'b00000000001000100011100000100101;//		OR  R7,R1,R2
								
								/*Address 32 */	inst_mem[8] =32'b00000000001000110010100000100110;//		XOR R5,R1,R3
								/*Address 36 */	inst_mem[9] =32'b00000000001000100011000000100111;//		NOR R6,R1,R2
								/*Address 40 */	inst_mem[10] =32'b00000000100000100011100000000000;//		SLL R7,R4,R2
								
								/*Address 44 */	inst_mem[11] =32'b00000000001000100010100000000010;//		SRL R5,R1,R2
								/*Address 48 */	inst_mem[12] =32'b00000000001000010010100000100000;//		add r5,r1,r1
								
								/*Address 52 */	inst_mem[13] =32'b00000000101001000011000000100010;//		sub r6,r5,r4	
								/*Address 56 */	inst_mem[14] =32'b00000000101001100011100000100100;//		and r7,r5,r6
								/*Address 60 */	inst_mem[15] =32'b00110100101001010000000000001111;//		ori r5,r5,0xf
								/*Address 64 */	inst_mem[16] =32'b10101100000000010000000000000000;//		sw r1, 0(r0)
								
								/*Address 68 */	inst_mem[17] =32'b10101100000001000000000000000100; //		sw r4, 1(r0)
								/*Address 72 */	inst_mem[18] =32'b10001100000001010000000000000000; //		lw r5, 0(r0)
								/*Address 76 */	inst_mem[19] =32'b10001100000001100000000000000100; //		lw r6,1(r0)	
								/*Address 80 */	inst_mem[20] =32'b00110000110001110000000000001011; //		andi r7,r6,0xb
								
								/*Address 84 */	inst_mem[21] =32'b10101100000001110000000000001000;//		sw r7,2(r0)	
								/*Address 88 */	inst_mem[22] =32'b10001100000001010000000000000000;//		lw r5,0(r0)
								/*Address 92 */	inst_mem[23] =32'b10101100000001010000000000001100;//		sw r5,3(r0)	
								
								/*Address 96 */	inst_mem[24] =32'b00010000001000010000000000000001//     beq r1, r1, P1
								/*Address 100 */	inst_mem[25] =32'b00000000010000100010100000100000//     add r5, r2, r2	
								/*Address 104 */	inst_mem[26] =32'b00010100000000010000000000000010//     bne r0, r1, P2
								/*Address 108 */	inst_mem[27] =32'b00000000010000100011000000100000//    add r6, r2, r2	
								/*Address 112 */	inst_mem[28] =32'b00000000100001000011100000100000//    add r7, r4, r4
								
								/*Address 116 */	inst_mem[29] =32'b00001000000000000000000000100000//     j P3	
								/*Address 120 */	inst_mem[30] =32'b00000000010000100010100000100000//    add r5, r2, r2	
								/*Address 124 */	inst_mem[31] =32'b00000000100001000011000000100000//    add r6, r4, r4	
								/*Address 128 */	inst_mem[32] =32'b00000000000000000000000000100000//    add r0, r0, r0

-------------------------------------------------------------------------------

					 //B.1

//inst_mem[0]=32'b10001100000000010000000000000000;
//inst_mem[1]=32'b00110100000000100000000000000100;
//inst_mem[2]=32'b00100000000000111111111111111110;
//inst_mem[3]=32'b10001100000001000000000000000100;
//inst_mem[4]=32'b00000000001000010010100000100000;
//inst_mem[5]=32'b00000000001000100011000000100010;
//inst_mem[6]=32'b00000000011001000011000000100100;
//inst_mem[7]=32'b00000000001000100011100000100101;
//inst_mem[8]=32'b00000000001000110010100000100110;
//inst_mem[9]=32'b00000000001000100011000000100111;
//inst_mem[10]=32'b00000000100000100011100000000000;
//inst_mem[11]=32'b00000000001000100010100000000010;
//inst_mem[12]=32'b00000000001000010010100000100000;
//inst_mem[13]=32'b00000000101001000011000000100010;
//inst_mem[14]=32'b00000000101001100011100000100100;
//inst_mem[15]=32'b00110100101001010000000000001111;
//inst_mem[16]=32'b10101100000000010000000000000000;
//inst_mem[17]=32'b10101100000001000000000000000100;
//inst_mem[18]=32'b10001100000001010000000000000000;
//inst_mem[19]=32'b10001100000001100000000000000100;
//inst_mem[20]=32'b00110000110001110000000000001011;
//inst_mem[21]=32'b10101100000001110000000000001000;
//inst_mem[22]=32'b10001100000001010000000000000000;
//inst_mem[23]=32'b10101100000001010000000000001100;
//inst_mem[24]=32'b00010000001000010000000000000001;
//inst_mem[25]=32'b00000000010000100010100000100000;
//inst_mem[26]=32'b00010100000000010000000000000010;
//inst_mem[27]=32'b00000000010000100011000000100000;
//inst_mem[28]=32'b00000000100001000011100000100000;
//inst_mem[29]=32'b00001000000000000000000000100000;
//inst_mem[30]=32'b00000000010000100010100000100000;
//inst_mem[31]=32'b00000000100001000011000000100000;
//inst_mem[32]=32'b00000000000000000000000000100000;



// Benchmark Two 

//B.2
//inst_mem[0]=32'b00001100000000000000000000000010;
//inst_mem[1]=32'b00001000000000000000000000011001;
//inst_mem[2]=32'b00100000000100000000000000000000;
//inst_mem[3]=32'b00100000000010000000000000000000;
//inst_mem[4]=32'b00100000000100010000000000010011;
//inst_mem[5]=32'b00011001000100010000000000010010;
//inst_mem[6]=32'b00100000000010010000000000000000;
//inst_mem[7]=32'b00000010001010010101000000100010;
//inst_mem[8]=32'b00011001001010100000000000001101;
//inst_mem[9]=32'b00000001001000000101100010000000;
//inst_mem[10]=32'b00000010000010110110000000100000;
//inst_mem[11]=32'b10001101100011010000000000000000;
//inst_mem[12]=32'b10001101100011100000000000000100;
//inst_mem[13]=32'b00011001101011100000000000000001;
//inst_mem[14]=32'b00001000000000000000000000010100;
//inst_mem[15]=32'b00000001101000000111100000100000;
//inst_mem[16]=32'b00000001110000000110100000100000;
//inst_mem[17]=32'b00000001111000000111000000100000;
//inst_mem[18]=32'b10101101100011010000000000000000;
//inst_mem[19]=32'b10101101100011100000000000000100;
//inst_mem[20]=32'b00100001001010010000000000000001;
//inst_mem[21]=32'b00001000000000000000000000001000;
//inst_mem[22]=32'b00100001000010000000000000000001;
//inst_mem[23]=32'b00001000000000000000000000000101;
//inst_mem[24]=32'b00000011111001010010000000001000;
//inst_mem[25]=32'b00000000000000000000000000100000;



 // initial begin // this should be removed because it is NOT synthesizable
	
	//-------------------------------------------------------------
	
	//testcase 6
//	
//	/*Address 0 */  inst_mem[0] = 32'b00000000000000000000100000100000; //ADD R1, R0, R0   
//	/*Address 4 */  inst_mem[1] = 32'b00000000000000000001000000100000; //ADD R2, R0, R0
//	/*Address 8 */  inst_mem[2] = 32'b00100000000010010000000001100100; //ADDI R9, R0, 100
//	/*Address 12 */ inst_mem[3] = 32'b00010000001010010000000000000010; //BEQ R1, R9, EXIT //START
//	/*Address 16 */ inst_mem[4] = 32'b00100000001000010000000000000001; //ADDI R1, R1, 1
//	/*Address 20 */ inst_mem[5] = 32'b00001000000000000000000000000011; //JUMP START
//	/*Address 24 */ inst_mem[6] = 32'b00000000001000100001100000100000; //ADD R3, R1, R2 //EXIT
	
	
	//testcase 5 
	
	//a=2
//	/*Address 0 */  inst_mem[0] = 32'b00100000000000010000000000000010; //ADDI R1, R0, 2 (a)
//	/*Address 4 */  inst_mem[1] = 32'b00100000000000100000000000000010; //ADDI R2, R0, 2 (b)
//	/*Address 8 */  inst_mem[2] = 32'b00100000010000110000000000000011; //ADDI R3, R2, 3 (b+3)
//	/*Address 12 */ inst_mem[3] = 32'b00100100001000110000000000000010; //BGE  R1, R3, THEN Hazard Unit
//	/*Address 16 */ inst_mem[4] = 32'b00100000001000010000000000000001; //ADDI R1, R1, 1
//	/*Address 20 */ inst_mem[5] = 32'b00001000000000000000000000000111; //JUMP END
//	/*Address 24 */ inst_mem[6] = 32'b00100000001000010000000000000010; //ADDI R1, R1, 2 //THEN 
//	/*Address 28 */ inst_mem[7] = 32'b00000000010000010001000000100000; //ADD R2, R2, R1 //END
	
	//a=6
//	
//	/*Address 0 */  inst_mem[0] = 32'b00100000000000010000000000000110; //ADDI R1, R0, 6 (a)
//	/*Address 4 */  inst_mem[1] = 32'b00100000000000100000000000000010; //ADDI R2, R0, 2 (b)
//	/*Address 8 */  inst_mem[2] = 32'b00100000010000110000000000000011; //ADDI R3, R2, 3 (b+3)
//	/*Address 12 */ inst_mem[3] = 32'b00100100001000110000000000000010; //BGE  R1, R3, THEN
//	/*Address 16 */ inst_mem[4] = 32'b00100000001000010000000000000001; //ADDI R1, R1, 1
//	/*Address 20 */ inst_mem[5] = 32'b00001000000000000000000000000111; //JUMP END
//	/*Address 24 */ inst_mem[6] = 32'b00100000001000010000000000000010; //ADDI R1, R1, 2 //THEN 
//	/*Address 28 */ inst_mem[7] = 32'b00000000010000010001000000100000; //ADD R2, R2, R1 //END
//	
	
	//-------------------------------------------------------------
	//testcase 4
	
	
//	
//	/*Address 0 */  inst_mem[0] = 32'b00000000000000000100000000100000; //ADD R8, R0, R0
//	/*Address 4 */  inst_mem[1] = 32'b00100000000010010000000000001010; //ADDI R9, R9, 10
//	/*Address 8 */  inst_mem[2] = 32'b00000001000010010101000000100010; //SUB R10, R8, R9 //Loop Forwarding 
//	/*Address 12 */ inst_mem[3] = 32'b00100000000011000000000000000001; //ADDI R12, R0, 1
//	/*Address 16 */ inst_mem[4] = 32'b00011001000010010000000000000010; //BGT R8, R9, DONE
//	/*Address 20 */ inst_mem[5] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1
//	/*Address 24 */ inst_mem[6] = 32'b00001000000000000000000000000010; //JUMP LOOP
//	/*Address 28 */ inst_mem[7] = 32'b00000001001000000110100000100000; //ADD R13, R9, R0 //DONE
//	/*Address 32 */ inst_mem[8] = 32'b00100000000011100000000000011011; //ADDI R14, R0, 1B(27)
//	/*Address 36 */ inst_mem[9] = 32'b00110001110011100000000000010111; //ANDI R14, R14, 17(23) Forwarding
	
	// do not forget to put a high cycle such as 50000 cycle
	//-------------------------------------------------------------
	//testcase 3
	
//	inst_mem[0] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)
//	inst_mem[1] = 32'b10001111100010000000000000000000; //LW R8, 0(R28)
//	inst_mem[2] = 32'b10001111100010010000000000000100; //LW R9, 4(R28)
//	inst_mem[3] = 32'b00000001000010010100000000100000; //ADD R8, R8, R9 Hazard & Forwarding
//	inst_mem[4] = 32'b10001111100010100000000000001000; //LW R10, 8(R28)
//	inst_mem[5] = 32'b00000001010010100101000000100000; //ADD R10, R10, R10 Hazard & Forwarding
//	inst_mem[6] = 32'b00000001000010100100000000100010; //SUB R8, R8, R10
//	inst_mem[7] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1 Forwarding
//	inst_mem[8] = 32'b00000000000010000100000000100010; //SUB R8, R0, R8 Forwarding
	
	
	
	//-------------------------------------------------------------
	
	
	//testcase 2	

//   inst_mem[0] = 32'b10001100000000010000000000001000; //LW R1, 8(R0)
//	inst_mem[1] = 32'b00000000001000000000100010000000; //SLL R1, R1, 2 
//	inst_mem[2] = 32'b10101100000000010000000000000100; //SW R1, 4(R0) 
//	inst_mem[3] = 32'b10001100000000100000000000010000; //LW R2, 16(R0)
//	inst_mem[4] = 32'b10001100000000110000000000010000; //LW R3, 16(R0)
//	inst_mem[5] = 32'b00000000010000000001100001000000; //SLL R3, R2, 1 (There is a problem wee need Forwarding to solve it and hazard detection )
//	inst_mem[6] = 32'b10101100000000110000000000001100; //SW R3, 12(R0)
//	inst_mem[7] = 32'b10001100000001000000000000001100; //LW R4, 12(R0)
//	
	
	
	//testcase 1
	
//	inst_mem[0] = 32'b10001100000010000000000000000000; //LW R8, 0(R0)
//	inst_mem[1] = 32'b10001100000010010000000000100000; //LW R9, 0x20(R0)
//	inst_mem[2] = 32'b10001100000010100000000001010000; //LW R10, 0x50(R0)
//	inst_mem[3] = 32'b10001100000010110000000000001000; //LW R11, 0x8(R0)
//	
	//-------------------------------------------------------------
	//THIS TEST FOR BLT 
	/*
	inst_mem[0] = 32'b10001100000000010000000000000100;//lw reg1=3 
	inst_mem[1] = 32'b10001100001000100000000000000101;//lw reg2=8 
	inst_mem[2] = 32'b00011100001000100000000000000001;//bLt address=16 -->4*1+12 **should work**
	inst_mem[3] = 32'b10001100001000110000000000010001;//lw reg3=20   **should not work**
	inst_mem[4] = 32'b10001100010001000000000000000100;//lw reg4=12   **should work**
	*/
	
	// THIS TEST FOR JS & JAL INSTRUCTIONS
    // the goal is to make a infinite loop
//	/*Address 0 */inst_mem[0] = 32'b00001100000000000000000000000100;//JAL Jump to address 16 and save R31 = 4
//	/*Address 4 */inst_mem[1] = 32'b10001100000000010000000000000100;//lw reg1=3 (the jump will skip it) ** should not work**
//	/*Address 8 */inst_mem[2] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)  ** should not work**
//	/*Address 12 */inst_mem[3] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)  ** should not work**
//	/*Address 16 */inst_mem[4] = 32'b00000011111001010010000000001000;// JS jump to address store in REG 31 so jump to address 4 (here we want forwarding to let this instruction wrok correclty )
//	/*Address 20 */inst_mem[5] = 32'b00000000000000000100000000100000; //ADD R8, R0, R0
	//inst_mem[5] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)  ** should not work**
	
	
	
	// THIS TEST FOR STACK TESTING USING JAL & JS INSTRUCTIONS (Nested Subroutine) 3 push 3 pull 
	// the goal is test the stack functionality 
	
//	/*Address 0 */inst_mem[0] = 32'b00001100000000000000000000000100;//JAL Jump to address 16 and save R31 = 4
//	/*Address 4 */inst_mem[1] = 32'b10001100000000010000000000000100;//lw reg1=3 (the jump will skip it) ** should not work**
//	/*Address 8 */inst_mem[2] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)  ** should not work**
//	
//	/*Address 16 */inst_mem[4] = 32'b00001100000000000000000000000111;//JAL Jump to address 28 and save R31 = 20
//
//	   
//   /*Address 20 */inst_mem[5] = 32'b00000011111001010010000000001000;// JS jump to address store in REG 31 so jump to address 4 (here we want forwarding to let this instruction wrok correclty )
//	
//	
//	/*Address 28 */inst_mem[7] = 32'b00001100000000000000000000001111;//JAL Jump to address 60 and save R31 = 32
//		
//	/*Address 32 */inst_mem[8] = 32'b00000011111001010010000000001000;// JS jump to address store in REG 31 so jump to address 20 (here we want forwarding to let this instruction wrok correclty )
//		
//	/*Address 60 */inst_mem[15] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)  ** should not work**
//		
//    /*Address 64 */inst_mem[16] = 32'b00000011111001010010000000001000;// JS jump to address store in REG 31 so jump to address 32 (here we want forwarding to let this instruction wrok correclty )
	 

	
//*******************************************Implemtation of PUSH & PULL Instructions ************************************************************	
	
	
	
	
	
	
	
	//THIS TEST FOR BLT not working
	/*
	inst_mem[0] = 32'b10001100000000010000000000000100;//lw reg1=3 
	inst_mem[1] = 32'b10001100001000100000000000000101;//lw reg2=8 
	inst_mem[2] = 32'b00011100010000010000000000000001;//bLt address=16 -->4*1+12 **should not work**
	inst_mem[3] = 32'b10001100001000110000000000010001;//lw reg3=20   **should work**
	inst_mem[4] = 32'b10001100010001000000000000000100;//lw reg4=12   **should work**
	*/
	
	
	//THIS TEST FOR BGT 
	/*
	inst_mem[0] = 32'b10001100000000010000000000000100;//lw reg1=3 
	inst_mem[1] = 32'b10001100001000100000000000000101;//lw reg2=8 
	inst_mem[2] = 32'b00011000010000010000000000000001;//bgt address=16 -->4*1+12 **should work**
	inst_mem[3] = 32'b10001100001000110000000000010001;//lw reg3=20   **should not work**
	inst_mem[4] = 32'b10001100010001000000000000000100;//lw reg4=12   **should work**
   */
	
	
	//THIS TEST FOR BGT not working
	/*
	inst_mem[0] = 32'b10001100000000010000000000000100;//lw reg1=3 
	inst_mem[1] = 32'b10001100001000100000000000000101;//lw reg2=8 
	inst_mem[2] = 32'b00011000001000100000000000000001;//bgt address=16 -->4*1+12 **should not work**
	inst_mem[3] = 32'b10001100001000110000000000010001;//lw reg3=20   **should work**
	inst_mem[4] = 32'b10001100010001000000000000000100;//lw reg4=12   **should work**
	*/
	
	//THIS TEST FOR BNE
	/*
	inst_mem[0] = 32'b10001100000000010000000000000100;//lw reg1=3 
	inst_mem[1] = 32'b10001100001000100000000000000101;//lw reg2=8 
	inst_mem[2] = 32'b00010100001000100000000000000001;//bne address=16 -->4*1+12 **should not work**
	inst_mem[3] = 32'b10001100001000110000000000010001;//lw reg3=20   **should not work**
	inst_mem[4] = 32'b10001100010001000000000000000100;//lw reg4=12   **should work**
	*/
	
	//THIS TEST FOR BNE not working
	/*
	inst_mem[0] = 32'b10001100000000010000000000000100;//lw reg1=3 
	inst_mem[1] = 32'b10001100000000100000000000000100;//lw reg2=3 
	inst_mem[2] = 32'b00010100001000100000000000000001;//bne address=16 -->4*1+12
	inst_mem[3] = 32'b10001100001000110000000000010001;//lw reg3=20 **should work**
	inst_mem[4] = 32'b10001100010001000000000000001001;//lw reg4=12   **should work**
	*/
	
	//THIS TEST FOR BEQ
	/*
	inst_mem[0] = 32'b10001100000000010000000000000100;//lw reg1=3 
	inst_mem[1] = 32'b10001100000000100000000000000100;//lw reg2=3 
	inst_mem[2] = 32'b00010000001000100000000000000001;//beq address=16 -->4*1+12
	inst_mem[3] = 32'b10001100001000110000000000010001;//lw reg3=20 **should not work**
	inst_mem[4] = 32'b10001100010001000000000000001001;//lw reg4=12   **should work**
	*/
	
	
	//THIS TEST FOR BEQ not working
	/*
	inst_mem[0] = 32'b10001100000000010000000000000100;//lw reg1=3 
	inst_mem[1] = 32'b10001100001000100000000000000101;//lw reg2=8 
	inst_mem[2] = 32'b00010000001000100000000000000001;//beq address=16 -->4*1+12 **should not work**
	inst_mem[3] = 32'b10001100001000110000000000010001;//lw reg3=20   **should work**
	inst_mem[4] = 32'b10001100010001000000000000000100;//lw reg4=12   **should work**
	*/
	
	
	/*  THIS TEST FOR JUMP INSTRUCTIONS
	inst_mem[0] = 32'b10001100000000010000000000001100;//load 12 in reg1
	inst_mem[1] = 32'b00001100000000000000000000000011;//jump to inst_mem[3] and save pc+1 in reg31 (jal)
// inst_mem[1] = 32'b00000000001000000000000000001000;//jump to content of reg1 (pc=12) 
//	inst_mem[1] = 32'b00001000000000000000000000000100;//jump to inst_mem[4] and skip inst_mem[3]
	inst_mem[2] = 32'b10001100000000100000000000010100;//load 20 in reg2
   inst_mem[3] = 32'b10001100000000110000000000001000;//load 8 in reg3
	*/

/*	
  inst_mem[0] = 32'b10001100000000010000000000000100;		 //LW		$1 , $4(0)  -> load the content of address (content of reg 0 + 4=4) in ram to reg1 =3
  inst_mem[1] = 32'b10001100001000100000000000000101;		 //LW 	$2 , $5(1)	-> load the content of address (content of reg 3 + 5=8) in ram to reg2 =8
  inst_mem[2] = 32'b00000000001000100101000000100000;		 //add 	$10,$1,$2   -> add  the content of reg 1 and 2 then store it in reg 10 = 11
  inst_mem[3] = 32'b10001100001000110000000000010001;     //LW 	$3 , $17(1) -> load the content of address (content of reg 1(3) + 17=20) in ram to reg3 =20
  inst_mem[4] = 32'b00100000010001010000000000000110;		 //addi 	$5,$2,6		-> add  the content of reg2 to 6 (8+6 =14) then store it in reg5 =14
  inst_mem[5] = 32'b10001100010001000000000000000100;		 //LW 	$4 , $4(3)  -> load the content of address (content of reg2 (8) + 4=12) in ram to reg4 =12
  inst_mem[6] = 32'b00000000101000010011000000100010;		 //sub 	$6,$5,$1		-> sub  the content of reg1 from reg5 (14-3=11) then store it in reg6=11
  inst_mem[7] = 32'b00000000001000100011100000100010;		 //sub   $7,$1,$2		-> sub  the content of reg10 from reg1 (3-8=-5) then store it in reg7=-5
  inst_mem[8] = 32'b00000000001010100100000000100100;		 //and   $8,$1,$10   -> and  the content of reg10 with reg2 (ans:3) then store it in reg8=3
  inst_mem[9] = 32'b00000000001010100100100000100101;		 //or	   $9,$1,$10   -> or   the content of reg10 with reg2 (ans:11) then store it in reg9=11
  inst_mem[10] = 32'b00000000110001000101100000100110;	 //xor   $11,$4,$6	-> xor   the content of reg15 with reg10 (ans:3) then store it in reg11=7
  inst_mem[11] = 32'b00000000010001100110000000100111;	 //nor   $12,$2,$6	-> nor   the content of reg15 with reg10 (ans:8) then store it in reg12=-12
  inst_mem[12] = 32'b00000000001001110110100000011000;	 //mul   $13,$1,$7	-> mul   the content of reg1 with reg7 (ans:-5*3=-15) then store it in reg13=-15
  inst_mem[13] = 32'b00000000100010000111000000011010;	 //div   $14,$4,$8	-> div   the content of reg4 by reg8 (ans:12/3=4) then store it in reg14 = 4
  inst_mem[14] = 32'b00000001000000000100000010000000;	 //sll   $8 ,$0,$8	-> reg8=3*4=12
  inst_mem[15] = 32'b00000001000000000100000010000010;	 //slr   $8 ,$0,$8	-> reg8=12/4=3
  inst_mem[16] = 32'b10101100000001010000000000101000;	 //sw    $5,$40($0)	-> sw {m[40]=14} 					
  inst_mem[17] = 32'b10001100000011110000000000101000; 	 //lw 	$15,$40($0) -> reg15 = m[40] = 14	
  inst_mem[18] = 32'b00110100100100000000000000000101;	 //ori	$16,$4,5 	-> or the content of reg4 (1100) with 5(0101) and sw in reg16=13
  inst_mem[19] = 32'b00110000100100010000000000000101;	 //andi  $17,$4,5		-> and the content of reg4 (1100) with 5(0101) and sw in reg17=4
  inst_mem[20] = 32'b10001100000100100000000000101100;	 //LW		$18,$44($0) -> reg18=big num
  inst_mem[21] = 32'b10001100000100110000000000101100; 	 //LW		$19,$44($0) -> reg19=big num
  inst_mem[22] = 32'b00000010010100111010000000100000;	 //add	$20,$18,$19 -> reg20= 32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
  inst_mem[23] = 32'b10001100000101010000000000110100;	 //LW		$21,$0(0)
  inst_mem[24] = 32'b10001100000101100000000000111000;	 //Lw		$22,$40(0)
  inst_mem[25] = 32'b00000010101101101011100000100001;	 //addu	$23,22,21 	-> should do unsigned overflow !
  inst_mem[26] = 32'b00000000111011011100000000100001;	 //addu	$24,$7,$13 -> reg24= should do unsigned overflow !
  inst_mem[27] = 32'b00000000111011011100100000100000;	 //add	$25,$7,$13 -> reg25= -20
  inst_mem[28] = 32'b00000000111011011101000000100011;	 //subu	$26,$7,$13 -> reg26= 10
  inst_mem[29] = 32'b00000000111011011101100000100010;	 //sub	$27,$7,$13 -> reg27= 10*/

  
 /*
checking LW muliable times

 inst_mem[0] = 32'b10001100000000010000000000000100; //reg1=3
  inst_mem[1] = 32'b10001100001000100000000000000101; //reg2=8
  inst_mem[2] = 32'b10001100001000110000000000010001; //reg3=20
  inst_mem[3] = 32'b10001100000011110000000000101000; //reg15=14
  inst_mem[4] = 32'b10001100000100100000000000101100; //reg18=big
  inst_mem[5] = 32'b10001100000100110000000000101100; //reg19=big
  inst_mem[6] = 32'b10001100000101010000000000101100; //reg21=big_num
  inst_mem[7] = 32'b10101100000101010000000000000000;// m[0]=big_num
  inst_mem[8] = 32'b10001100000101100000000000000000;//reg22=big*/
 // end