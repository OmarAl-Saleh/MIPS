Benchmark One : 

 
					 for (i = 0; i < 3300; i = i + 33) begin
		  //Benchmark 1
	
		inst_mem[0+i]=32'b10001100000000010000000000000000;
		inst_mem[1+i]=32'b00110100000000100000000000000100;
		inst_mem[2+i]=32'b00100000000000111111111111111110;
		inst_mem[3+i]=32'b10001100000001000000000000000100;
		inst_mem[4+i]=32'b00000000001000010010100000100000;
		inst_mem[5+i]=32'b00000000001000100011000000100010;
		inst_mem[6+i]=32'b00000000011001000011000000100100;
		inst_mem[7+i]=32'b00000000001000100011100000100101;
		inst_mem[8+i]=32'b00000000001000110010100000100110;
		inst_mem[9+i]=32'b00000000001000100011000000100111;
		inst_mem[10+i]=32'b00000000100000100011100000000000;
		inst_mem[11+i]=32'b00000000001000100010100000000010;
		inst_mem[12+i]=32'b00000000001000010010100000100000;
		inst_mem[13+i]=32'b00000000101001000011000000100010;
		inst_mem[14+i]=32'b00000000101001100011100000100100;
		inst_mem[15+i]=32'b00110100101001010000000000001111;
		inst_mem[16+i]=32'b10101100000000010000000000000000;
		inst_mem[17+i]=32'b10101100000001000000000000000100;
		inst_mem[18+i]=32'b10001100000001010000000000000000;
		inst_mem[19+i]=32'b10001100000001100000000000000100;
		inst_mem[20+i]=32'b00110000110001110000000000001011;
		inst_mem[21+i]=32'b10101100000001110000000000001000;
		inst_mem[22+i]=32'b10001100000001010000000000000000;
		inst_mem[23+i]=32'b10101100000001010000000000001100;
		inst_mem[24+i]=32'b00010000001000010000000000000001;
		
		inst_mem[25+i]=32'b00000000010000100010100000100000;
		
		inst_mem[26+i]=32'b00010100000000010000000000000010;
		inst_mem[27+i]=32'b00000000010000100011000000100000;
		inst_mem[28+i]=32'b00000000100001000011100000100000;
		
		//inst_mem[29+i]=32'b00001000000000000000000000100000; jump cuase problem
		 inst_mem[29+i]=32'b00010000001000010000000000000010; // we use a branch instead beq r1,r1,p3
		 
		inst_mem[30+i]=32'b00000000010000100010100000100000;
		inst_mem[31+i]=32'b00000000100001000011000000100000;
		inst_mem[32+i]=32'b00000000000000000000000000100000;
      end




/* LAST ADDRESS */ inst_mem[3300] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

**********************Benchmark Two ************************************************************

			 
					 for (i = 0; i < 2600; i = i + 26) begin
		  //Benchmark 2
		  
			inst_mem[0+i]=32'b00001100000000000000000000000010;
			
			//inst_mem[1+i]=32'b00001000000000000000000000011001; // JUMP End 
			
			inst_mem[1+i]=32'b00010000000000000000000000010111; // beq r0,r0,End (23 instruction between (offset))
			
			inst_mem[2+i]=32'b00100000000100000000000000000000;
			inst_mem[3+i]=32'b00100000000010000000000000000000;
			inst_mem[4+i]=32'b00100000000100010000000000010011;
			inst_mem[5+i]=32'b00011001000100010000000000010010;//sel1
			inst_mem[6+i]=32'b00100000000010010000000000000000;
			inst_mem[7+i]=32'b00000010001010010101000000100010;
			inst_mem[8+i]=32'b00011001001010100000000000001101; // sel2
			inst_mem[9+i]=32'b00000001001000000101100010000000;
			inst_mem[10+i]=32'b00000010000010110110000000100000;
			inst_mem[11+i]=32'b10001101100011010000000000000000;
			inst_mem[12+i]=32'b10001101100011100000000000000100;
			inst_mem[13+i]=32'b00011001101011100000000000000001;
			
		//	inst_mem[14+i]=32'b00001000000000000000000000010100; // Jump --> ES
		
			inst_mem[14+i]=32'b00010000000000000000000000000101;//beq r0,r0,ES (offset 5)
			
			inst_mem[15+i]=32'b00000001101000000111100000100000;
			inst_mem[16+i]=32'b00000001110000000110100000100000;
			inst_mem[17+i]=32'b00000001111000000111000000100000;
			inst_mem[18+i]=32'b10101101100011010000000000000000;
			inst_mem[19+i]=32'b10101101100011100000000000000100;
			inst_mem[20+i]=32'b00100001001010010000000000000001; //ES
			
			//inst_mem[21+i]=32'b00001000000000000000000000001000;//Jump -->  8 sel2
			 
			 inst_mem[21+i]=32'b00010000000000001111111111110010; // beq r0,r0 , sel2 offset(-14)

			
			inst_mem[22+i]=32'b00100001000010000000000000000001;
			
			
		//	inst_mem[23+i]=32'b00001000000000000000000000000101;// JUMP --> 5 sel 1
		
		   inst_mem[23+i]=32'b 00010000000000001111111111101101; // beq r0,r0,sel1 offset(-19)
			
			inst_mem[24+i]=32'b00000011111001010010000000001000;
			inst_mem[25+i]=32'b00000000000000000000000000100000;
	
		
      end
	

Evaluation Instruction Memory: 


***********************************************************************************************
test case 1 : 

module INST_MEM #(
  //parameter size = 32,
  parameter size = 500,  
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
   //reg [31:0] inst_mem [0:size - 1];
	
	reg [31:0] inst_mem [0:499];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
        for (i = 0; i < 400; i = i + 4) begin
		  //testcase 1
	
			inst_mem[i] = 32'b10001100000010000000000000000000; //LW R8, 0(R0)
			inst_mem[i+1] = 32'b10001100000010010000000000100000; //LW R9, 0x20(R0)
			inst_mem[i+2] = 32'b10001100000010100000000001010000; //LW R10, 0x50(R0)
			inst_mem[i+3] = 32'b10001100000010110000000000001000; //LW R11, 0x8(R0)
      end
	
	
	
//-------------------------------------------------------------

//

/* LAST ADDRESS */ inst_mem[400] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule

**********************************************************************************************************************************************************************
**********************************************************************************************************************************************************************

test case 2


module INST_MEM #(
    parameter size = 32,
//  parameter size = 1000,  
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
  // reg [31:0] inst_mem [0:size - 1];
	
   reg [31:0] inst_mem [0:850];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
	// to run Benchmark instruction 100 times
	
        for (i = 0; i < 800; i = i + 8) begin
		  
   inst_mem[i+0] = 32'b10001100000000010000000000001000; //LW R1, 8(R0)
	inst_mem[i+1] = 32'b00000000001000000000100010000000; //SLL R1, R1, 2 
	inst_mem[i+2] = 32'b10101100000000010000000000000100; //SW R1, 4(R0) 
	inst_mem[i+3] = 32'b10001100000000100000000000010000; //LW R2, 16(R0)
	inst_mem[i+4] = 32'b10001100000000110000000000010000; //LW R3, 16(R0)
	inst_mem[i+5] = 32'b00000000010000000001100001000000; //SLL R3, R2, 1 
	inst_mem[i+6] = 32'b10101100000000110000000000001100; //SW R3, 12(R0)
	inst_mem[i+7] = 32'b10001100000001000000000000001100; //LW R4, 12(R0)
	
      end

      /* LAST ADDRESS */ inst_mem[800] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time

// inst_mem[0] = 32'b10001100000000010000000000001000; //LW R1, 8(R0)
//	inst_mem[1] = 32'b00000000001000000000100010000000; //SLL R1, R1, 2 
//	inst_mem[2] = 32'b10101100000000010000000000000100; //SW R1, 4(R0) 
//	inst_mem[3] = 32'b10001100000000100000000000010000; //LW R2, 16(R0)
//	inst_mem[4] = 32'b10001100000000110000000000010000; //LW R3, 16(R0)
//	inst_mem[5] = 32'b00000000010000000001100001000000; //SLL R3, R2, 1 
//	inst_mem[6] = 32'b10101100000000110000000000001100; //SW R3, 12(R0)
//	inst_mem[7] = 32'b10001100000001000000000000001100; //LW R4, 12(R0)
//	
	
	
//-------------------------------------------------------------

//

///* LAST ADDRESS */ inst_mem[8] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule


*********************************************************************************************************************************
*********************************************************************************************************************************

test case 3 


module INST_MEM #(
    parameter size = 32,
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
  //reg [31:0] inst_mem [0:size - 1];
  
   reg [31:0] inst_mem [0:950];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
//	// to run Benchmark instruction 100 times
	
        for (i = 0; i < 900; i = i + 9) begin
		  
//testcase 3
	
	inst_mem[i+0] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)
	inst_mem[i+1] = 32'b10001111100010000000000000000000; //LW R8, 0(R28)
	inst_mem[i+2] = 32'b10001111100010010000000000000100; //LW R9, 4(R28)
	inst_mem[i+3] = 32'b00000001000010010100000000100000; //ADD R8, R8, R9 Hazard & Forwarding
	inst_mem[i+4] = 32'b10001111100010100000000000001000; //LW R10, 8(R28)
	inst_mem[i+5] = 32'b00000001010010100101000000100000; //ADD R10, R10, R10 Hazard & Forwarding
	inst_mem[i+6] = 32'b00000001000010100100000000100010; //SUB R8, R8, R10
	inst_mem[i+7] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1 Forwarding
	inst_mem[i+8] = 32'b00000000000010000100000000100010; //SUB R8, R0, R8 Forwarding
      end

      /* LAST ADDRESS */ inst_mem[900] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time

	//testcase 3
	
//	inst_mem[0] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)
//	inst_mem[1] = 32'b10001111100010000000000000000000; //LW R8, 0(R28)
//	inst_mem[2] = 32'b10001111100010010000000000000100; //LW R9, 4(R28)
//	inst_mem[3] = 32'b00000001000010010100000000100000; //ADD R8, R8, R9 Hazard & Forwarding
//	inst_mem[4] = 32'b10001111100010100000000000001000; //LW R10, 8(R28)
//	inst_mem[5] = 32'b00000001010010100101000000100000; //ADD R10, R10, R10 Hazard & Forwarding
//	inst_mem[6] = 32'b00000001000010100100000000100010; //SUB R8, R8, R10
//	inst_mem[7] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1 Forwarding
//	inst_mem[8] = 32'b00000000000010000100000000100010; //SUB R8, R0, R8 Forwarding
	
//-------------------------------------------------------------



///* LAST ADDRESS */ inst_mem[9] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule

***************************************************************************************************************************************************
***************************************************************************************************************************************************

test case 4




module INST_MEM #(
    parameter size = 32,
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
//  reg [31:0] inst_mem [0:size - 1];
  
   reg [31:0] inst_mem [0:1050];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
//	// to run Benchmark instruction 100 times
	
        for (i = 0; i < 1000; i = i + 10) begin
		  
//testcase 4
	
	// it will not halt because of JUMP to Address 8 
	
	/*Address 0 */  inst_mem[i+0] = 32'b00000000000000000100000000100000; //ADD R8, R0, R0
	/*Address 4 */  inst_mem[i+1] = 32'b00100000000010010000000000001010; //ADDI R9, R9, 10
	/*Address 8 */  inst_mem[i+2] = 32'b00000001000010010101000000100010; //SUB R10, R8, R9 //Loop Forwarding 
	/*Address 12 */ inst_mem[i+3] = 32'b00100000000011000000000000000001; //ADDI R12, R0, 1
	/*Address 16 */ inst_mem[i+4] = 32'b00011001000010010000000000000010; //BGT R8, R9, DONE
	/*Address 20 */ inst_mem[i+5] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1
	/*Address 24 */ inst_mem[i+6] = 32'b00001000000000000000000000000010; //JUMP LOOP
	/*Address 28 */ inst_mem[i+7] = 32'b00000001001000000110100000100000; //ADD R13, R9, R0 //DONE
	/*Address 32 */ inst_mem[i+8] = 32'b00100000000011100000000000011011; //ADDI R14, R0, 1B(27)
	/*Address 36 */ inst_mem[i+9] = 32'b00110001110011100000000000010111; //ANDI R14, R14, 17(23) Forwarding
      end

     /* LAST ADDRESS */ inst_mem[1000] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time

	//testcase 4
	
	
	
//	/*Address 0 */  inst_mem[0] = 32'b00000000000000000100000000100000; //ADD R8, R0, R0
//	/*Address 4 */  inst_mem[1] = 32'b00100000000010010000000000001010; //ADDI R9, R9, 10
//	/*Address 8 */  inst_mem[2] = 32'b00000001000010010101000000100010; //SUB R10, R8, R9 //Loop Forwarding 
//	/*Address 12 */ inst_mem[3] = 32'b00100000000011000000000000000001; //ADDI R12, R0, 1
//	/*Address 16 */ inst_mem[4] = 32'b00011001000010010000000000000010; //BGT R8, R9, DONE
//	/*Address 20 */ inst_mem[5] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1
//	/*Address 24 */ inst_mem[6] = 32'b00001000000000000000000000000010; //JUMP LOOP
//	/*Address 28 */ inst_mem[7] = 32'b00000001001000000110100000100000; //ADD R13, R9, R0 //DONE
//	/*Address 32 */ inst_mem[8] = 32'b00100000000011100000000000011011; //ADDI R14, R0, 1B(27)
//	/*Address 36 */ inst_mem[9] = 32'b00110001110011100000000000010111; //ANDI R14, R14, 17(23) Forwarding
//	
////-------------------------------------------------------------
//
//
//
///* LAST ADDRESS */ inst_mem[10] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule

***************************************************************************************************************************************************************
****************************************************************************************************************************************************************

test case 5 

module INST_MEM #(
    parameter size = 32,
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
//  reg [31:0] inst_mem [0:size - 1];
  
   reg [31:0] inst_mem [0:1050];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
//	// to run Benchmark instruction 100 times
	
//        for (i = 0; i < 1000; i = i + 10) begin
//		  
////testcase 4 ,5 , 6
//	
//	// it will not halt because of JUMP OR Branch can't be looped 
//	
//	
//      end
//
//     /* LAST ADDRESS */ inst_mem[1000] = 32'b10110100001000100001100000100000; //Halt 
//// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time

	//testcase 5
	
	
	
//testcase 5 
	
	//a=2
	/*Address 0 */  inst_mem[0] = 32'b00100000000000010000000000000010; //ADDI R1, R0, 2 (a)
	/*Address 4 */  inst_mem[1] = 32'b00100000000000100000000000000010; //ADDI R2, R0, 2 (b)
	/*Address 8 */  inst_mem[2] = 32'b00100000010000110000000000000011; //ADDI R3, R2, 3 (b+3)
	/*Address 12 */ inst_mem[3] = 32'b00100100001000110000000000000010; //BGE  R1, R3, THEN Hazard Unit
	/*Address 16 */ inst_mem[4] = 32'b00100000001000010000000000000001; //ADDI R1, R1, 1
	/*Address 20 */ inst_mem[5] = 32'b00001000000000000000000000000111; //JUMP END
	/*Address 24 */ inst_mem[6] = 32'b00100000001000010000000000000010; //ADDI R1, R1, 2 //THEN 
	/*Address 28 */ inst_mem[7] = 32'b00000000010000010001000000100000; //ADD R2, R2, R1 //END
//-------------------------------------------------------------



/* LAST ADDRESS */ inst_mem[8] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule
****************************************************************************************************
*****************************************************************************************************

module INST_MEM #(
    parameter size = 32,
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
  reg [31:0] inst_mem [0:size - 1];
  
  // reg [31:0] inst_mem [0:1050];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
//	// to run Benchmark instruction 100 times
	
//        for (i = 0; i < 1000; i = i + 10) begin
//		  
////testcase 4 ,5 , 6
//	
//	// it will not halt because of JUMP OR Branch can't be looped 
//	
//	
//      end
//
//     /* LAST ADDRESS */ inst_mem[1000] = 32'b10110100001000100001100000100000; //Halt 
//// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time


//testcase 6
	
	/*Address 0 */  inst_mem[0] = 32'b00000000000000000000100000100000; //ADD R1, R0, R0   
	/*Address 4 */  inst_mem[1] = 32'b00000000000000000001000000100000; //ADD R2, R0, R0
	/*Address 8 */  inst_mem[2] = 32'b00100000000010010000000001100100; //ADDI R9, R0, 100
	/*Address 12 */ inst_mem[3] = 32'b00010000001010010000000000000010; //BEQ R1, R9, EXIT //START
	/*Address 16 */ inst_mem[4] = 32'b00100000001000010000000000000001; //ADDI R1, R1, 1
	/*Address 20 */ inst_mem[5] = 32'b00001000000000000000000000000011; //JUMP START
	/*Address 24 */ inst_mem[6] = 32'b00000000001000100001100000100000; //ADD R3, R1, R2 //EXIT
//-------------------------------------------------------------



/* LAST ADDRESS */ inst_mem[7] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule













