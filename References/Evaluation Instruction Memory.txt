Evaluation Instruction Memory: 


***********************************************************************************************
test case 1 : 

module INST_MEM #(
  //parameter size = 32,
  parameter size = 500,  
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
   //reg [31:0] inst_mem [0:size - 1];
	
	reg [31:0] inst_mem [0:499];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
        for (i = 0; i < 400; i = i + 4) begin
		  //testcase 1
	
			inst_mem[i] = 32'b10001100000010000000000000000000; //LW R8, 0(R0)
			inst_mem[i+1] = 32'b10001100000010010000000000100000; //LW R9, 0x20(R0)
			inst_mem[i+2] = 32'b10001100000010100000000001010000; //LW R10, 0x50(R0)
			inst_mem[i+3] = 32'b10001100000010110000000000001000; //LW R11, 0x8(R0)
      end
	
	
	
//-------------------------------------------------------------

//

/* LAST ADDRESS */ inst_mem[400] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule

**********************************************************************************************************************************************************************
**********************************************************************************************************************************************************************

test case 2


module INST_MEM #(
    parameter size = 32,
//  parameter size = 1000,  
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
  // reg [31:0] inst_mem [0:size - 1];
	
   reg [31:0] inst_mem [0:850];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
	// to run Benchmark instruction 100 times
	
        for (i = 0; i < 800; i = i + 8) begin
		  
   inst_mem[i+0] = 32'b10001100000000010000000000001000; //LW R1, 8(R0)
	inst_mem[i+1] = 32'b00000000001000000000100010000000; //SLL R1, R1, 2 
	inst_mem[i+2] = 32'b10101100000000010000000000000100; //SW R1, 4(R0) 
	inst_mem[i+3] = 32'b10001100000000100000000000010000; //LW R2, 16(R0)
	inst_mem[i+4] = 32'b10001100000000110000000000010000; //LW R3, 16(R0)
	inst_mem[i+5] = 32'b00000000010000000001100001000000; //SLL R3, R2, 1 
	inst_mem[i+6] = 32'b10101100000000110000000000001100; //SW R3, 12(R0)
	inst_mem[i+7] = 32'b10001100000001000000000000001100; //LW R4, 12(R0)
	
      end

      /* LAST ADDRESS */ inst_mem[800] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time

// inst_mem[0] = 32'b10001100000000010000000000001000; //LW R1, 8(R0)
//	inst_mem[1] = 32'b00000000001000000000100010000000; //SLL R1, R1, 2 
//	inst_mem[2] = 32'b10101100000000010000000000000100; //SW R1, 4(R0) 
//	inst_mem[3] = 32'b10001100000000100000000000010000; //LW R2, 16(R0)
//	inst_mem[4] = 32'b10001100000000110000000000010000; //LW R3, 16(R0)
//	inst_mem[5] = 32'b00000000010000000001100001000000; //SLL R3, R2, 1 
//	inst_mem[6] = 32'b10101100000000110000000000001100; //SW R3, 12(R0)
//	inst_mem[7] = 32'b10001100000001000000000000001100; //LW R4, 12(R0)
//	
	
	
//-------------------------------------------------------------

//

///* LAST ADDRESS */ inst_mem[8] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule


*********************************************************************************************************************************
*********************************************************************************************************************************

test case 3 


module INST_MEM #(
    parameter size = 32,
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
  //reg [31:0] inst_mem [0:size - 1];
  
   reg [31:0] inst_mem [0:950];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
//	// to run Benchmark instruction 100 times
	
        for (i = 0; i < 900; i = i + 9) begin
		  
//testcase 3
	
	inst_mem[i+0] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)
	inst_mem[i+1] = 32'b10001111100010000000000000000000; //LW R8, 0(R28)
	inst_mem[i+2] = 32'b10001111100010010000000000000100; //LW R9, 4(R28)
	inst_mem[i+3] = 32'b00000001000010010100000000100000; //ADD R8, R8, R9 Hazard & Forwarding
	inst_mem[i+4] = 32'b10001111100010100000000000001000; //LW R10, 8(R28)
	inst_mem[i+5] = 32'b00000001010010100101000000100000; //ADD R10, R10, R10 Hazard & Forwarding
	inst_mem[i+6] = 32'b00000001000010100100000000100010; //SUB R8, R8, R10
	inst_mem[i+7] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1 Forwarding
	inst_mem[i+8] = 32'b00000000000010000100000000100010; //SUB R8, R0, R8 Forwarding
      end

      /* LAST ADDRESS */ inst_mem[900] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time

	//testcase 3
	
//	inst_mem[0] = 32'b00000000000000001110000000000000; //ADD R28,R0,R0 (R28=0)
//	inst_mem[1] = 32'b10001111100010000000000000000000; //LW R8, 0(R28)
//	inst_mem[2] = 32'b10001111100010010000000000000100; //LW R9, 4(R28)
//	inst_mem[3] = 32'b00000001000010010100000000100000; //ADD R8, R8, R9 Hazard & Forwarding
//	inst_mem[4] = 32'b10001111100010100000000000001000; //LW R10, 8(R28)
//	inst_mem[5] = 32'b00000001010010100101000000100000; //ADD R10, R10, R10 Hazard & Forwarding
//	inst_mem[6] = 32'b00000001000010100100000000100010; //SUB R8, R8, R10
//	inst_mem[7] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1 Forwarding
//	inst_mem[8] = 32'b00000000000010000100000000100010; //SUB R8, R0, R8 Forwarding
	
//-------------------------------------------------------------



///* LAST ADDRESS */ inst_mem[9] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule

***************************************************************************************************************************************************
***************************************************************************************************************************************************

test case 4




module INST_MEM #(
    parameter size = 32,
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
//  reg [31:0] inst_mem [0:size - 1];
  
   reg [31:0] inst_mem [0:1050];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
//	// to run Benchmark instruction 100 times
	
        for (i = 0; i < 1000; i = i + 10) begin
		  
//testcase 4
	
	// it will not halt because of JUMP to Address 8 
	
	/*Address 0 */  inst_mem[i+0] = 32'b00000000000000000100000000100000; //ADD R8, R0, R0
	/*Address 4 */  inst_mem[i+1] = 32'b00100000000010010000000000001010; //ADDI R9, R9, 10
	/*Address 8 */  inst_mem[i+2] = 32'b00000001000010010101000000100010; //SUB R10, R8, R9 //Loop Forwarding 
	/*Address 12 */ inst_mem[i+3] = 32'b00100000000011000000000000000001; //ADDI R12, R0, 1
	/*Address 16 */ inst_mem[i+4] = 32'b00011001000010010000000000000010; //BGT R8, R9, DONE
	/*Address 20 */ inst_mem[i+5] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1
	/*Address 24 */ inst_mem[i+6] = 32'b00001000000000000000000000000010; //JUMP LOOP
	/*Address 28 */ inst_mem[i+7] = 32'b00000001001000000110100000100000; //ADD R13, R9, R0 //DONE
	/*Address 32 */ inst_mem[i+8] = 32'b00100000000011100000000000011011; //ADDI R14, R0, 1B(27)
	/*Address 36 */ inst_mem[i+9] = 32'b00110001110011100000000000010111; //ANDI R14, R14, 17(23) Forwarding
      end

     /* LAST ADDRESS */ inst_mem[1000] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time

	//testcase 4
	
	
	
//	/*Address 0 */  inst_mem[0] = 32'b00000000000000000100000000100000; //ADD R8, R0, R0
//	/*Address 4 */  inst_mem[1] = 32'b00100000000010010000000000001010; //ADDI R9, R9, 10
//	/*Address 8 */  inst_mem[2] = 32'b00000001000010010101000000100010; //SUB R10, R8, R9 //Loop Forwarding 
//	/*Address 12 */ inst_mem[3] = 32'b00100000000011000000000000000001; //ADDI R12, R0, 1
//	/*Address 16 */ inst_mem[4] = 32'b00011001000010010000000000000010; //BGT R8, R9, DONE
//	/*Address 20 */ inst_mem[5] = 32'b00100001000010000000000000000001; //ADDI R8, R8, 1
//	/*Address 24 */ inst_mem[6] = 32'b00001000000000000000000000000010; //JUMP LOOP
//	/*Address 28 */ inst_mem[7] = 32'b00000001001000000110100000100000; //ADD R13, R9, R0 //DONE
//	/*Address 32 */ inst_mem[8] = 32'b00100000000011100000000000011011; //ADDI R14, R0, 1B(27)
//	/*Address 36 */ inst_mem[9] = 32'b00110001110011100000000000010111; //ANDI R14, R14, 17(23) Forwarding
//	
////-------------------------------------------------------------
//
//
//
///* LAST ADDRESS */ inst_mem[10] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule

***************************************************************************************************************************************************************
****************************************************************************************************************************************************************

test case 5 

module INST_MEM #(
    parameter size = 32,
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
//  reg [31:0] inst_mem [0:size - 1];
  
   reg [31:0] inst_mem [0:1050];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
//	// to run Benchmark instruction 100 times
	
//        for (i = 0; i < 1000; i = i + 10) begin
//		  
////testcase 4 ,5 , 6
//	
//	// it will not halt because of JUMP OR Branch can't be looped 
//	
//	
//      end
//
//     /* LAST ADDRESS */ inst_mem[1000] = 32'b10110100001000100001100000100000; //Halt 
//// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time

	//testcase 5
	
	
	
//testcase 5 
	
	//a=2
	/*Address 0 */  inst_mem[0] = 32'b00100000000000010000000000000010; //ADDI R1, R0, 2 (a)
	/*Address 4 */  inst_mem[1] = 32'b00100000000000100000000000000010; //ADDI R2, R0, 2 (b)
	/*Address 8 */  inst_mem[2] = 32'b00100000010000110000000000000011; //ADDI R3, R2, 3 (b+3)
	/*Address 12 */ inst_mem[3] = 32'b00100100001000110000000000000010; //BGE  R1, R3, THEN Hazard Unit
	/*Address 16 */ inst_mem[4] = 32'b00100000001000010000000000000001; //ADDI R1, R1, 1
	/*Address 20 */ inst_mem[5] = 32'b00001000000000000000000000000111; //JUMP END
	/*Address 24 */ inst_mem[6] = 32'b00100000001000010000000000000010; //ADDI R1, R1, 2 //THEN 
	/*Address 28 */ inst_mem[7] = 32'b00000000010000010001000000100000; //ADD R2, R2, R1 //END
//-------------------------------------------------------------



/* LAST ADDRESS */ inst_mem[8] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule
****************************************************************************************************
*****************************************************************************************************

module INST_MEM #(
    parameter size = 32,
  parameter data_width = 32    
)(
 // input clk,
  input reset,                   
  input [31:0] address,
  output reg [31:0] inst_out

);
  reg [31:0] inst_mem [0:size - 1];
  
  // reg [31:0] inst_mem [0:1050];

  
 
 integer i;

//  endmodule 

reg state = 1'b0;
  
  
//  
  always @(*) begin

    if (reset) begin
      for (i = 0; i < size; i = i + 1) begin
        inst_mem[i] <= 32'b0;
      end
		  
    end else begin
        case (state)
            1'b0: begin
                state <= 1'b1;
					 // Enter here the Instructions of the program 
	
//	// to run Benchmark instruction 100 times
	
//        for (i = 0; i < 1000; i = i + 10) begin
//		  
////testcase 4 ,5 , 6
//	
//	// it will not halt because of JUMP OR Branch can't be looped 
//	
//	
//      end
//
//     /* LAST ADDRESS */ inst_mem[1000] = 32'b10110100001000100001100000100000; //Halt 
//// every program should end with halt signal 

//--------------------------------------------------------------------------------------------------

// to run benchmark instruction 1 time


//testcase 6
	
	/*Address 0 */  inst_mem[0] = 32'b00000000000000000000100000100000; //ADD R1, R0, R0   
	/*Address 4 */  inst_mem[1] = 32'b00000000000000000001000000100000; //ADD R2, R0, R0
	/*Address 8 */  inst_mem[2] = 32'b00100000000010010000000001100100; //ADDI R9, R0, 100
	/*Address 12 */ inst_mem[3] = 32'b00010000001010010000000000000010; //BEQ R1, R9, EXIT //START
	/*Address 16 */ inst_mem[4] = 32'b00100000001000010000000000000001; //ADDI R1, R1, 1
	/*Address 20 */ inst_mem[5] = 32'b00001000000000000000000000000011; //JUMP START
	/*Address 24 */ inst_mem[6] = 32'b00000000001000100001100000100000; //ADD R3, R1, R2 //EXIT
//-------------------------------------------------------------



/* LAST ADDRESS */ inst_mem[7] = 32'b10110100001000100001100000100000; //Halt 
// every program should end with halt signal 

	

	 
                
            end
            1'b1: begin

          inst_out <= inst_mem[address >> 2];
             
            end
            
        endcase
    end
end

endmodule













